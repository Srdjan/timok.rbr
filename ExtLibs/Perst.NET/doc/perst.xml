<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Perst.NET</name>
    </assembly>
    <members>
        <member name="T:Perst.Key">
            <summary> Class for specifying key value (neededd to access obejct by key usig index)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Boolean)">
            <summary> Constructor of boolean key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.SByte)">
            <summary> Constructor of signed byte key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte)">
            <summary> Constructor of byte key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char)">
            <summary> Constructor of char key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int16)">
            <summary> Constructor of short key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt16)">
            <summary> Constructor of unsigned short key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int32)">
            <summary> Constructor of int key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt32)">
            <summary> Constructor of unsigned int key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Enum)">
            <summary> Constructor of enum key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int64)">
            <summary> Constructor of long key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt64)">
            <summary> Constructor of unsigned long key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Single)">
            <summary> Constructor of float key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Double)">
            <summary> Constructor of double key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Decimal)">
            <summary> Constructor of decimal key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Guid)">
            <summary> Constructor of Guid key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.DateTime)">
            <summary> Constructor of date key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.String)">
            <summary> Constructor of string key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.IComparable)">
            <summary> Constructor of key of user defined type (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char[])">
            <summary> Constructor of array of char key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte[])">
            <summary> Constructor of array of byte key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object[])">
            <summary>
            Constructor of compound key (boundary is inclusive)
            </summary>
            <param name="v">array of compound key values</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Object)">
            <summary>
            Constructor of compound key with two values (boundary is inclusive)
            </summary>
            <param name="v1">first value of compund key</param>
            <param name="v2">second value of compund key</param>
        </member>
        <member name="M:Perst.Key.#ctor(Perst.IPersistent)">
            <summary> Constructor of key with persistent object reference (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Boolean,System.Boolean)">
            <summary> Constructor of boolean key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.SByte,System.Boolean)">
            <summary> Constructor of signed byte key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte,System.Boolean)">
            <summary> Constructor of byte key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char,System.Boolean)">
            <summary> Constructor of char key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int16,System.Boolean)">
            <summary> Constructor of short key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt16,System.Boolean)">
            <summary> Constructor of unsigned short key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Enum,System.Boolean)">
            <summary> Constructor of int key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int32,System.Boolean)">
            <summary> Constructor of int key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt32,System.Boolean)">
            <summary> Constructor of unsigned int key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int64,System.Boolean)">
            <summary> Constructor of long key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt64,System.Boolean)">
            <summary> Constructor of unsigned long key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Single,System.Boolean)">
            <summary> Constructor of float key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Double,System.Boolean)">
            <summary> Constructor of double key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Decimal,System.Boolean)">
            <summary> Constructor of decimal key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Guid,System.Boolean)">
            <summary> Constructor of Guid key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.DateTime,System.Boolean)">
            <summary> Constructor of date key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.String,System.Boolean)">
            <summary> Constructor of string key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char[],System.Boolean)">
            <summary> Constructor of array of char key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte[],System.Boolean)">
            <summary> Constructor of array of byte key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object[],System.Boolean)">
            <summary>
            Constructor of compound key (boundary is inclusive)
            </summary>
            <param name="v">array of compound key values</param>
            <param name="inclusive">whether boundary is inclusive or exclusive</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Object,System.Boolean)">
            <summary>
            Constructor of compound key with two values (boundary is inclusive)
            </summary>
            <param name="v1">first value of compund key</param>
            <param name="v2">second value of compund key</param>
            <param name="inclusive">whether boundary is inclusive or exclusive</param>
        </member>
        <member name="M:Perst.Key.#ctor(Perst.IPersistent,System.Boolean)">
            <summary> Constructor of key with persistent object reference
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.IComparable,System.Boolean)">
            <summary> Constructor of key of user defined type
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="T:Perst.PersistentResource">
            <summary>Base class for persistent capable objects supporting locking
            </summary>
        </member>
        <member name="T:Perst.Persistent">
            <summary> Base class for all persistent capable objects
            </summary>
        </member>
        <member name="T:Perst.IPersistent">
            <summary> Interface of all persistent capable objects
            </summary>
        </member>
        <member name="M:Perst.IPersistent.Load">
            <summary> Load object from the database (if needed)
            </summary>
        </member>
        <member name="M:Perst.IPersistent.IsRaw">
            
            <summary> Check if object is stub and has to be loaded from the database
            </summary>
            <param name="return"><code>true</code> if object has to be loaded from the database
            
            </param>
        </member>
        <member name="M:Perst.IPersistent.IsPersistent">
            <summary> Check if object is persistent 
            </summary>
            <returns><code>true</code> if object has assigned OID
            
            </returns>
        </member>
        <member name="M:Perst.IPersistent.IsDeleted">
            <summary>  Check if object is deleted by GC from process memory
            </summary>
            <returns> <code>true</code> if object is deleted by GC
            </returns>
        </member>
        <member name="M:Perst.IPersistent.IsModified">
            <summary> Check if object was modified within current transaction
            </summary>
            <returns><code>true</code> if object is persistent and was modified within current transaction
            
            </returns>
        </member>
        <member name="M:Perst.IPersistent.MakePersistent(Perst.Storage)">
            <summary> Explicitely make object peristent. Usually objects are made persistent
            implicitlely using "persistency on reachability apporach", but this
            method allows to do it explicitly 
            </summary>
            <param name="storage">storage in which object should be stored
            
            </param>
        </member>
        <member name="M:Perst.IPersistent.Store">
            <summary> Save object in the database
            </summary>
        </member>
        <member name="M:Perst.IPersistent.Modify">
            <summary>
            Mark object as modified. Object will be saved to the database during transaction commit.
            </summary>
        </member>
        <member name="M:Perst.IPersistent.Deallocate">
            <summary> Deallocate persistent object from the database
            </summary>
        </member>
        <member name="M:Perst.IPersistent.RecursiveLoading">
            <summary> Specified whether object should be automatically loaded when it is referenced
            by other loaded peristent object. Default implementation of this method
            returns <code>true</code> making all cluster of referenced objects loaded together. 
            To avoid main memory overflow you should stop recursive loading of all objects
            from the database to main memory by redefining this method in some classes and returing
            <code>false</code> in it. In this case object has to be loaded explicitely 
            using Persistent.load method.
            </summary>
            <returns><code>true</code> if object is automatically loaded
            
            </returns>
        </member>
        <member name="M:Perst.IPersistent.OnLoad">
            <summary> This method is  called by the database after loading of the object.
            It can be used to initialize transient fields of the object. 
            Default implementation of this method do nothing 
            </summary>
        </member>
        <member name="M:Perst.IPersistent.OnStore">
            <summary> This method is  called by the database befire storing of the object.
            It can be used to initialize transient fields of the object. 
            Default implementation of this method do nothing 
            </summary>
        </member>
        <member name="M:Perst.IPersistent.Invalidate">
            <summary>
            Invalidate object. Invalidated object has to be explicitly
            reloaded using load() method. Attempt to store invalidated object
            will cause StoraegError exception.
            </summary>
        </member>
        <member name="M:Perst.IPersistent.AssignOid(Perst.Storage,System.Int32,System.Boolean)">
            <summary>
            Method used to associate object with storage.
            This method is used by Storage class and you should not use it explicitly.
            </summary>
            <param name="storage">storage to be assigned to</param>
            <param name="oid">assigned OID</param>
            <param name="raw">if object is already loaded</param>
        </member>
        <member name="P:Perst.IPersistent.Oid">
            <summary> Get object identifier (OID)
            </summary>
        </member>
        <member name="P:Perst.IPersistent.Storage">
            <summary> Get storage in which this object is stored
            </summary>
        </member>
        <member name="T:Perst.IResource">
            <summary>
             Interface of object supporting locking
             </summary>
        </member>
        <member name="M:Perst.IResource.SharedLock">
            <summary>
            Lock persistent object in shared mode. Other threads will be able to set their
            shared locks on this objects, but not exclusive lock can be set until this lock is released.
            
            Upgrading of the lock is not possible (thread having read lock can not upgrade it to exclusive lock).
            It is done to prevent possible deadlocks caused by lock updates. 
            But locks are reentrant - so thread can request the same lock many times (and correspondent 
            number of unlocks is needed to release the lock).
            
            Locking the object doesn't prevent other threads from accessing the object - 
            it only has influence on <code>sharedLock</code> and <code>exclusiveLock</code> methods.
            So programmer should set proper lock before accessing the object in multithreaded application.
            
            If object is concurrently accessed by several threads in read-only mode, then explicit locking
            of this object is not needed, because language API provides consistent retrieving of objects itself.
            
            Only persistent object (object which were assigned to the the storage either implicitly by
            saving some other persistent object referencing this object, either explicitly by 
            <code>Storage.makeObjectPersistent</code> method.
            </summary>
        </member>
        <member name="M:Perst.IResource.ExclusiveLock">
             <summary>
             Lock persistent object in exclusive mode. Only one thread can lock object in exclusive mode at each
             moment of time. Shared or exclusive lock requests of other threads will be blocked until
             this lock is released.
             shared locks on this objects, but not exclusive lock can be set until this lock is released.
             
             This lock is reentrant, so thread owning the lock can successfully retrieve the lock many times
             (and correspondent number of unlocks is needed to release the lock).
             
             Locking the object doesn't prevent other threads from accessing the object - 
             it only has influence on <code>sharedLock</code> and <code>exclusiveLock</code> methods.
             So programmer should set proper lock before accessing the object in multithreaded application.
            
             Only persistent object (object which were assigned to the the storage either implicitly by
             saving some other persistent object referencing this object, either explicitly by 
             <code>Storage.makeObjectPersistent</code> method.   
             </summary>
        </member>
        <member name="M:Perst.IResource.SharedLock(System.Int64)">
            <summary>
            Lock persistent object in shared mode. Other threads will be able to set their
            shared locks on this objects, but not exclusive lock can be set until this lock is released.
            
            Upgrading of the lock is not possible (thread having read lock can not upgrade it to exclusive lock).
            It is done to prevent possible deadlocks caused by lock updates. 
            But locks are reentrant - so thread can request the same lock many times (and correspondent 
            number of unlocks is needed to release the lock).
             
            Locking the object doesn't prevent other threads from accessing the object - 
            it only has influence on <code>sharedLock</code> and <code>exclusiveLock</code> methods.
            So programmer should set proper lock before accessing the object in multithreaded application.
            
            If object is concurrently accessed by several threads in read-only mode, then explicit locking
            of this object is not needed, because language API provides consistent retrieving of objects itself.
            
            Only persistent object (object which were assigned to the the storage either implicitly by
            saving some other persistent object referencing this object, either explicitly by 
            <code>Storage.makeObjectPersistent</code> method.
            </summary>
            <param name="timeout">timeout of operation in milliseconds. If timeout is 0 and
            lock can not be granted, the request will fail immediately. Otherwise the system will try
            to grant lock within specified amount of time.
            </param>
            <returns>
            <DL>
            <DT><code>true</code> if lock is successfully granted</DT>
            <DT><code>false</code> if lock can not be granted within specified time</DT> 
            </DL>
            </returns>
        </member>
        <member name="M:Perst.IResource.ExclusiveLock(System.Int64)">
             <summary>
             Lock persistent object in exclusive mode. Only one thread can lock object in exclusive mode at each
             moment of time. Shared or exclusive lock requests of other threads will be blocked until
             this lock is released.
             shared locks on this objects, but not exclusive lock can be set until this lock is released.
             
             This lock is reentrant, so thread owning the lock can successfully retrieve the lock many times
             (and correspondent number of unlocks is needed to release the lock).
             
             Locking the object doesn't prevent other threads from accessing the object - 
             it only has influence on <code>sharedLock</code> and <code>exclusiveLock</code> methods.
            So programmer should set proper lock before accessing the object in multithreaded application.
            
             Only persistent object (object which were assigned to the the storage either implicitly by
             saving some other persistent object referencing this object, either explicitly by 
             <code>Storage.makeObjectPersistent</code> method.   
             </summary>
             <param name="timeout">timeout of operation in milliseconds. If timeout is 0 and
             lock can not be granted, the request will fail immediately. Otherwise the system will try
             to grant lock within specified amount of time.
             </param>
             <returns>
             <DL>
             <DT><code>true</code> if lock is successfully granted</DT>
             <DT><code>false</code> if lock can not be granted within specified time</DT>
             </DL>
             </returns>
        </member>
        <member name="M:Perst.IResource.Unlock">
            <summary>
            Remove granted lock. If lock was requested several times by one thread, then correspondent number
            of unlocks is needed to release the lock.
            </summary>
        </member>
        <member name="M:Perst.IResource.Reset">
            <summary>
            Reset resource to original state.
            Wakrup all threads waiting for this resource.
            </summary>
        </member>
        <member name="T:Perst.Index">
            <summary> Interface of object index.
            Index is used to provide fast access to the object by key. 
            Object in the index are stored ordered by key value. 
            It is possible to select object using exact value of the key or 
            select set of objects which key belongs to the specified interval 
            (each boundary can be specified or unspecified and can be inclusive or exclusive)
            Key should be of scalar, String, java.util.Date or peristent object type.
            </summary>
        </member>
        <member name="M:Perst.Index.Get(Perst.Key)">
            <summary> Get object by key (exact match)     
            </summary>
            <param name="key">wrapper of the specified key. It should match with type of the index and should be inclusive.
            </param>
            <returns>object with this value of the key or <code>null</code> if key nmot found
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) exception if there are more than 
            one objects in the index with specified value of the key.
            
            </exception>
        </member>
        <member name="M:Perst.Index.Get(System.Object)">
            <summary> Get object by key (exact match)     
            </summary>
            <param name="key">specified key value. It should match with type of the index and should be inclusive.
            </param>
            <returns>object with this value of the key or <code>null</code> if key nmot found
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) exception if there are more than 
            one objects in the index with specified value of the key.
            
            </exception>
        </member>
        <member name="M:Perst.Index.Get(Perst.Key,Perst.Key)">
            <summary> Get objects which key value belongs to the specified range.
            Either from boundary, either till boundary either both of them can be <code>null</code>.
            In last case the method returns all objects from the index.
            </summary>
            <param name="from">low boundary. If <code>null</code> then low boundary is not specified.
            Low boundary can be inclusive or exclusive. 
            </param>
            <param name="till">high boundary. If <code>null</code> then high boundary is not specified.
            High boundary can be inclusive or exclusive. 
            </param>
            <returns>array of objects which keys belongs to the specified interval, ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.Index.Get(System.Object,System.Object)">
            <summary> Get objects which key value belongs to the specified inclusive range.
            Either from boundary, either till boundary either both of them can be <code>null</code>.
            In last case the method returns all objects from the index.
            </summary>
            <param name="from">Inclusive low boundary. If <code>null</code> then low boundary is not specified.
            </param>
            <param name="till">Inclusive high boundary. If <code>null</code> then high boundary is not specified.
            </param>
            <returns>array of objects which keys belongs to the specified interval, ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.Index.GetPrefix(System.String)">
            <summary> Get objects which key starts with specifid prefix.
            </summary>
            <param name="prefix">String key prefix</param>
            <returns>array of objects which key starts with specifid prefix, ordered by key value 
            </returns>
        </member>
        <member name="M:Perst.Index.PrefixSearch(System.String)">
            <summary> 
            Locate all objects which key is prefix of specified word.
            </summary>
            <param name="word">string which prefixes are located in index</param>
            <returns>array of objects which key is prefix of specified word, ordered by key value
            </returns>
        </member>
        <member name="M:Perst.Index.Put(Perst.Key,Perst.IPersistent)">
            <summary> Put new object in the index. 
            </summary>
            <param name="key">object key wrapper
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns><code>true</code> if object is successfully inserted in the index, 
            <code>false</code> if index was declared as unique and there is already object with such value
            of the key in the index. 
            
            </returns>
        </member>
        <member name="M:Perst.Index.Put(System.Object,Perst.IPersistent)">
            <summary> Put new object in the index. 
            </summary>
            <param name="key">object key value
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns><code>true</code> if object is successfully inserted in the index, 
            <code>false</code> if index was declared as unique and there is already object with such value
            of the key in the index. 
            
            </returns>
        </member>
        <member name="M:Perst.Index.Set(Perst.Key,Perst.IPersistent)">
            <summary> Associate new value with the key. If there is already object with such key in the index, 
            then it will be removed from the index and new value associated with this key.
            </summary>
            <param name="key">object key wrapper
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns>object previously associated with this key, <code>null</code> if there was no such object
            </returns>
        </member>
        <member name="M:Perst.Index.Set(System.Object,Perst.IPersistent)">
            <summary> Associate new value with the key. If there is already object with such key in the index, 
            then it will be removed from the index and new value associated with this key.
            </summary>
            <param name="key">object key value
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns>object previously associated with this key, <code>null</code> if there was no such object
            </returns>
        </member>
        <member name="M:Perst.Index.Remove(Perst.Key,Perst.IPersistent)">
            <summary> Remove object with specified key from the tree.
            </summary>
            <param name="key">wrapper of the value of the key of removed object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index
            
            </exception>
        </member>
        <member name="M:Perst.Index.Remove(System.Object,Perst.IPersistent)">
            <summary> Remove object with specified key from the tree.
            </summary>
            <param name="key">value of the key of removed object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index
            
            </exception>
        </member>
        <member name="M:Perst.Index.Remove(Perst.Key)">
            <summary> Remove key from the unique index.
            </summary>
            <param name="key">wrapper of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="M:Perst.Index.Remove(System.Object)">
            <summary> Remove key from the unique index.
            </summary>
            <param name="key">value of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="M:Perst.Index.Size">
            <summary> Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            
            </returns>
        </member>
        <member name="M:Perst.Index.Clear">
            <summary> Remove all objects from the index
            </summary>
        </member>
        <member name="M:Perst.Index.ToArray">
            <summary> Get all objects in the index as array orderd by index key
            </summary>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.Index.ToArray(System.Type)">
            <summary> Get all objects in the index as array of specified type orderd by index key
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.Index.GetEnumerator(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get iterator for traversing objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.Index.GetEnumerator(System.Object,System.Object,Perst.IterationOrder)">
             <summary>
             Get iterator for traversing objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.Index.GetEnumerator(Perst.Key,Perst.Key)">
             <summary>
             Get iterator for traversing objects in ascent order belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.Index.GetEnumerator(System.Object,System.Object)">
             <summary>
             Get iterator for traversing objects in ascent order belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.Index.GetEnumerator(System.String)">
             <summary>
             Get iterator for traversing objects in ascent order which key starts with specified prefix. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="prefix">String key prefix</param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.Index.Range(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get enumerable collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.Index.Range(Perst.Key,Perst.Key)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.Index.Range(System.Object,System.Object,Perst.IterationOrder)">
             <summary>
             Get enumerable collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Inclusive low boundary. If <code>null</code> then low boundary is not specified.</param>
             <param name="till">Inclusive high boundary. If <code>null</code> then high boundary is not specified.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.Index.Range(System.Object,System.Object)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Inclusive low boundary. If <code>null</code> then low boundary is not specified.</param>
             <param name="till">Inclusive high boundary. If <code>null</code> then high boundary is not specified.</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.Index.StartsWith(System.String)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index which key starts with specified prefix. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="prefix">String key prefix</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.Index.GetDictionaryEnumerator">
             <summary>
             Get iterator for traversing all entries in the index 
             You should not update/remove or add members to the index during iteration
             </summary>
             <returns>entry iterator</returns>
            
        </member>
        <member name="M:Perst.Index.GetDictionaryEnumerator(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get iterator for traversing entries in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>AscanrOrder</code> or <code>DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="P:Perst.Index.Item(System.Object)">
            <summary> Access element by key
            </summary>
        </member>
        <member name="P:Perst.Index.KeyType">
            <summary>
            Get type of index key
            </summary>
            <returns>type of index key</returns>
        </member>
        <member name="T:Perst.FieldIndex">
            <summary> Interface of indexed field. 
            Index is used to provide fast access to the object by the value of indexed field. 
            Objects in the index are stored ordered by the value of indexed field. 
            It is possible to select object using exact value of the key or 
            select set of objects which key belongs to the specified interval 
            (each boundary can be specified or unspecified and can be inclusive or exclusive)
            Key should be of scalar, String, DateTime or peristent object type.
            </summary>
        </member>
        <member name="M:Perst.FieldIndex.Get(Perst.Key)">
            <summary> Get object by key (exact match)     
            </summary>
            <param name="key">specified key wrapper. It should match with type of the index and should be inclusive.
            </param>
            <returns>object with this value of the key or <code>null</code> if key nmot found
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) exception if there are more than 
            one objects in the index with specified value of the key.
            
            </exception>
        </member>
        <member name="M:Perst.FieldIndex.Get(System.Object)">
            <summary> Get object by key (exact match)     
            </summary>
            <param name="key">specified key value. It should match with type of the index and should be inclusive.
            </param>
            <returns>object with this value of the key or <code>null</code> if key nmot found
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) exception if there are more than 
            one objects in the index with specified value of the key.
            
            </exception>
        </member>
        <member name="M:Perst.FieldIndex.Get(Perst.Key,Perst.Key)">
            <summary> Get objects which key value belongs to the specified range.
            Either from boundary, either till boundary either both of them can be <code>null</code>.
            In last case the method returns all objects from the index.
            </summary>
            <param name="from">low boundary. If <code>null</code> then low boundary is not specified.
            Low boundary can be inclusive or exclusive. 
            </param>
            <param name="till">high boundary. If <code>null</code> then high boundary is not specified.
            High boundary can be inclusive or exclusive. 
            </param>
            <returns>array of objects which keys belongs to the specified interval, ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Get(System.Object,System.Object)">
            <summary> Get objects which key value belongs to the specified inclusive range.
            Either from boundary, either till boundary either both of them can be <code>null</code>.
            In last case the method returns all objects from the index.
            </summary>
            <param name="from">inclusive low boundary. If <code>null</code> then low boundary is not specified.
            </param>
            <param name="till">inclusive high boundary. If <code>null</code> then high boundary is not specified.
            </param>
            <returns>array of objects which keys belongs to the specified interval, ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.GetPrefix(System.String)">
            <summary> Get objects which key starts with specifid prefix.
            </summary>
            <param name="prefix">String key prefix</param>
            <returns>array of objects which key starts with specifid prefix, ordered by key value 
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.PrefixSearch(System.String)">
            <summary> 
            Locate all objects which key is prefix of specified word.
            </summary>
            <param name="word">string which prefixes are located in index</param>
            <returns>array of objects which key is prefix of specified word, ordered by key value
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Contains(Perst.IPersistent)">
            <summary> 
            Check if index contains specified object
            </summary>
            <param name="obj">object to be searched in the index. Object should contain indexed field. 
            </param>
            <returns><code>true</code> if object is present in the index, <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Put(Perst.IPersistent)">
            <summary> Put new object in the index. 
            </summary>
            <param name="obj">object to be inserted in index. Object should contain indexed field. 
            Object can be not yet persistent, in this case its forced to become persistent by assigning OID to it.
            </param>
            <returns><code>true</code> if object is successfully inserted in the index, 
            <code>false</code> if index was declared as unique and there is already object with such value
            of the key in the index. 
            
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Set(Perst.IPersistent)">
            <summary>
            Associate new object with the key specified by object field value. 
            If there is already object with such key in the index, 
            then it will be removed from the index and new value associated with this key.
            </summary>
            <param name="obj">object to be inserted in index. Object should contain indexed field. 
            Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns>object previously associated with this key, <code>null</code> if there was no such object
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Append(Perst.IPersistent)">
            <summary>
            Assign to the integer indexed field unique autoicremented value and 
            insert object in the index. 
            </summary>
            <param name="obj">object to be inserted in index. Object should contain indexed field
            of integer (<code>int</code> or <code>long</code>) type.
            This field is assigned unique value (which will not be reused while 
            this index exists) and object is marked as modified.
            Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <exception cref="T:Perst.StorageError"><code>StorageError(StorageError.ErrorCode.INCOMPATIBLE_KEY_TYPE)</code> 
            is thrown when indexed field has type other than <code>int</code> or <code>long</code></exception>
        </member>
        <member name="M:Perst.FieldIndex.Remove(Perst.IPersistent)">
            <summary> Remove object from the index
            </summary>
            <param name="obj">object removed from the index. Object should contain indexed field. 
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index
            
            </exception>
        </member>
        <member name="M:Perst.FieldIndex.Remove(Perst.Key)">
            <summary> Remove object with specified key from the unique index.
            </summary>
            <param name="key">wrapper of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="M:Perst.FieldIndex.Remove(System.Object)">
            <summary> Remove object with specified key from the unique index.
            </summary>
            <param name="key">value of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="M:Perst.FieldIndex.Size">
            <summary> Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Clear">
            <summary> Remove all objects from the index
            </summary>
        </member>
        <member name="M:Perst.FieldIndex.ToArray">
            <summary> Get all objects in the index as array orderd by index key
            </summary>
            <returns>array of specified type contaning objects in the index ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.ToArray(System.Type)">
            <summary> Get all objects in the index as array of specified type orderd by index key
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.GetEnumerator(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get iterator for traversing objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.GetEnumerator(System.Object,System.Object,Perst.IterationOrder)">
             <summary>
             Get iterator for traversing objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.GetEnumerator(Perst.Key,Perst.Key)">
             <summary>
             Get iterator for traversing objects in ascent order belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.GetEnumerator(System.Object,System.Object)">
             <summary>
             Get iterator for traversing objects in ascent order belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.GetEnumerator(System.String)">
             <summary>
             Get iterator for traversing objects in ascent order which key starts with specified prefix. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="prefix">String key prefix</param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.Range(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get enumerable collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.Range(Perst.Key,Perst.Key)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.Range(System.Object,System.Object,Perst.IterationOrder)">
             <summary>
             Get enumerable collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Inclusive low boundary. If <code>null</code> then low boundary is not specified.</param>
             <param name="till">Inclusive high boundary. If <code>null</code> then high boundary is not specified.</param>
             <param name="order"><code>IterationOrder.AscentOrder</code> or <code>IterationOrder.DescentOrder</code></param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.Range(System.Object,System.Object)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Inclusive low boundary. If <code>null</code> then low boundary is not specified.</param>
             <param name="till">Inclusive high boundary. If <code>null</code> then high boundary is not specified.</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.StartsWith(System.String)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index which key starts with specified prefix. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="prefix">String key prefix</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.GetDictionaryEnumerator">
             <summary>
             Get iterator for traversing all entries in the index 
             You should not update/remove or add members to the index during iteration
             </summary>
             <returns>entry terator</returns>
            
        </member>
        <member name="M:Perst.FieldIndex.GetDictionaryEnumerator(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get iterator for traversing entries in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><code>AscanrOrder</code> or <code>DescentOrder</code></param>
             <returns>selection iterator</returns>
            
        </member>
        <member name="P:Perst.FieldIndex.Item(System.Object)">
            <summary> Access element by key
            </summary>
        </member>
        <member name="P:Perst.FieldIndex.IndexedClass">
            <summary>
            Get class obejct objects which can be inserted in this index
            </summary>
            <returns>class specified in Storage.createFielIndex method</returns>
        </member>
        <member name="P:Perst.FieldIndex.KeyFields">
            <summary>
            Get fields used as a key
            </summary>
            <returns>array of index key fields</returns>
        </member>
        <member name="T:Perst.IFile">
            <summary> Interface of file.
            Prorgemmer can provide its own impleentation of this interface, adding such features
            as support of flash cards, encrypted files,...
            Implentation of this interface should throw StorageError exception in case of failure
            </summary>
        </member>
        <member name="M:Perst.IFile.Write(System.Int64,System.Byte[])">
            <summary> Write data to the file
            </summary>
            <param name="pos"> offset in the file
            </param>
            <param name="buf"> array with data to be writter (size is always equal to database page size)
            </param>
            
        </member>
        <member name="M:Perst.IFile.Read(System.Int64,System.Byte[])">
            <summary> Reade data from the file
            </summary>
            <param name="pos"> offset in the file
            </param>
            <param name="buf"> array to receive readen data (size is always equal to database page size)
            </param>
            <returns> param number of bytes actually readen
            </returns>
        </member>
        <member name="M:Perst.IFile.Sync">
            <summary> Flush all fiels changes to the disk
            </summary>
        </member>
        <member name="M:Perst.IFile.Close">
            <summary> Close file
            </summary>
        </member>
        <member name="T:Perst.TransparentPersistenceAttribute">
            <summary>
            Attribute providing transparent persistency for context bound objects.
            It should be used for classes derived from PeristentContext class.
            Objects of these classes automatically on demand load their 
            content from the database and also automatically detect object modification.
            </summary>
        </member>
        <member name="T:Perst.PatriciaTrie">
            <summary> 
            PATRICIA trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric).
            Tries are a kind of tree where each node holds a common part of one or more keys. 
            PATRICIA trie is one of the many existing variants of the trie, which adds path compression 
            by grouping common sequences of nodes together.
            This structure provides a very efficient way of storing values while maintaining the lookup time 
            for a key in O(N) in the worst case, where N is the length of the longest key. 
            This structure has it's main use in IP routing software, but can provide an interesting alternative 
            to other structures such as hashtables when memory space is of concern.
            </summary>
        </member>
        <member name="M:Perst.PatriciaTrie.Add(Perst.PatriciaTrieKey,Perst.IPersistent)">
             <summary> 
             Add new key to the trie
             </summary>
             <param name="key">bit vector</param>
             <param name="obj">persistent object associated with this key</param>
             <returns>previous object associtated with this key or <code>null</code> if there
             was no such object</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.FindBestMatch(Perst.PatriciaTrieKey)">
             <summary>
             Find best match with specified key
             </summary>
             <param name="key">bit vector</param>
             <returns>object associated with this deepest possible match with specified key</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.FindExactMatch(Perst.PatriciaTrieKey)">
             <summary>
             Find exact match with specified key
             </summary>
             <param name="key">bit vector</param>
             <returns>object associated with this key or NULL if match is not found</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.Remove(Perst.PatriciaTrieKey)">
             <summary>
             Removes key from the triesKFind exact match with specified key
             </summary>
             <param name="key">bit vector</param>
             <returns>object associated with removed key or <code>null</code> if such key is not found</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.Clear">
             <summary>
             Clear the trie: remove all elements from trie
             </summary>
            
        </member>
        <member name="T:Perst.MemoryUsage">
            <summary>
            Information about memory usage for the correspondent class. 
            Instances of this class are created by Storage.getMemoryDump method.
            Size of internal database structures (object index,* memory allocation bitmap) is associated with 
            <code>Storage</code> class. Size of class descriptors  - with <code>System.Type</code> class.
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.type">
            <summary>
            Class of persistent object or Storage for database internal data
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.nInstances">
            <summary>
            Number of reachable instance of the particular class in the database.
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.totalSize">
            <summary>
            Total size of all reachable instances
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.allocatedSize">
            <summary>
            Real allocated size of all instances. Database allocates space for th objects using quantums,
            for example object wilth size 25 bytes will use 32 bytes in the storage.
            In item associated with Storage class this field contains size of all allocated
            space in the database (marked as used in bitmap) 
            </summary>
        </member>
        <member name="M:Perst.MemoryUsage.#ctor(System.Type)">
            <summary>
            MemoryUsage constructor
            </summary>
        </member>
        <member name="T:Perst.Relation">
            <summary> Class representing relation between owner and members
            </summary>
        </member>
        <member name="T:Perst.Link">
            <summary> Interface for one-to-many relation. There are two types of relations:
            embedded (when references to the relarted obejcts are stored in lreation
            owner obejct itself) and stanalone (when relation is separate object, which contains
            the reference to the relation owner and relation members). Both kinds of relations
            implements Link interface. Embedded relation is created by Storage.createLink method
            and standalone relation is represented by Relation persistent class created by
            Storage.createRelation method.
            </summary>
        </member>
        <member name="M:Perst.Link.Size">
            <summary> Get number of the linked objects 
            </summary>
            <returns>the number of related objects
            
            </returns>
        </member>
        <member name="M:Perst.Link.Get(System.Int32)">
            <summary> Get related object by index
            </summary>
            <param name="i">index of the object in the relation
            </param>
            <returns>referenced object
            
            </returns>
        </member>
        <member name="M:Perst.Link.GetRaw(System.Int32)">
            <summary> Get related object by index without loading it.
            Returned object can be used only to get it OID or to compare with other objects using
            <code>equals</code> method
            </summary>
            <param name="i">index of the object in the relation
            </param>
            <returns>stub representing referenced object
            
            </returns>
        </member>
        <member name="M:Perst.Link.Set(System.Int32,Perst.IPersistent)">
            <summary> Replace i-th element of the relation
            </summary>
            <param name="i">index in the relartion
            </param>
            <param name="obj">object to be included in the relation     
            
            </param>
        </member>
        <member name="M:Perst.Link.Remove(System.Int32)">
            <summary> Remove object with specified index from the relation
            </summary>
            <param name="i">index in the relartion
            
            </param>
        </member>
        <member name="M:Perst.Link.Insert(System.Int32,Perst.IPersistent)">
            <summary> Insert new object in the relation
            </summary>
            <param name="i">insert poistion, should be in [0,size()]
            </param>
            <param name="obj">object inserted in the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.Add(Perst.IPersistent)">
            <summary> Add new object to the relation
            </summary>
            <param name="obj">object inserted in the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.AddAll(Perst.IPersistent[])">
            <summary> Add all elements of the array to the relation
            </summary>
            <param name="arr">array of obects which should be added to the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.AddAll(Perst.IPersistent[],System.Int32,System.Int32)">
            <summary> Add specified elements of the array to the relation
            </summary>
            <param name="arr">array of obects which should be added to the relation
            </param>
            <param name="from">index of the first element in the array to be added to the relation
            </param>
            <param name="length">number of elements in the array to be added in the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.AddAll(Perst.Link)">
            <summary> Add all object members of the other relation to this relation
            </summary>
            <param name="link">another relation
            
            </param>
        </member>
        <member name="M:Perst.Link.ToArray">
            <summary> Get relation members as array of objects
            </summary>
            <returns>created array</returns>
        </member>
        <member name="M:Perst.Link.ToRawArray">
            <summary> 
            Return array with relation members. Members are not loaded and 
            size of the array can be greater than actual number of members. 
            </summary>
            <returns>array of object with relation members used in implementation of Link class
            </returns>
        </member>
        <member name="M:Perst.Link.ToArray(System.Type)">
            <summary> Get relation members as array with specifed element type
            </summary>
            <param name="elemType">element type of created array</param>
            <returns>created array</returns>
        </member>
        <member name="M:Perst.Link.Contains(Perst.IPersistent)">
            <summary> Checks if relation contains specified object
            </summary>
            <param name="obj">specified object
            
            </param>
        </member>
        <member name="M:Perst.Link.ContainsElement(System.Int32,Perst.IPersistent)">
            <summary>Check if i-th element of Link is the same as specified obj
            </summary>
            <param name="i"> element index</param>
            <param name="obj">specified object</param>
            <returns><code>true</code> if i-th element of Link reference the same object as "obj"</returns>
        </member>
        <member name="M:Perst.Link.IndexOf(Perst.IPersistent)">
            <summary> Get index of the specified object in the relation
            </summary>
            <param name="obj">specified object
            </param>
            <returns>zero based index of the object or -1 if object is not in the relation
            
            </returns>
        </member>
        <member name="M:Perst.Link.Clear">
            <summary> Remove all members from the relation
            </summary>
        </member>
        <member name="M:Perst.Link.Unpin">
            <summary>
            Replace all direct references to linked objects with stubs. 
            This method is needed tyo avoid memory exhaustion in case when 
            there is a large numebr of objectys in databasse, mutually
            refefencing each other (each object can directly or indirectly 
            be accessed from other objects).
            </summary>
        </member>
        <member name="M:Perst.Link.Pin">
            <summary>
            Replace references to elements with direct references.
            It will impove spped of manipulations with links, but it can cause
            recursive loading in memory large number of objects and as a result - memory
            overflow, because garabge collector will not be able to collect them
            </summary>
        </member>
        <member name="P:Perst.Link.Length">
            <summary>Number of the linked objects 
            </summary>
        </member>
        <member name="P:Perst.Link.Item(System.Int32)">
            <summary> Access element by index
            </summary>
        </member>
        <member name="M:Perst.Relation.#ctor(Perst.IPersistent)">
            <summary> Relation constructor. Creates empty relation with specified owner and no members. 
            Members can be added to the relation later.
            </summary>
            <param name="owner">owner of the relation
            
            </param>		
        </member>
        <member name="T:Perst.TimeSeries">
            <summary>
            <p>
            Time series interface. Time series class is used for efficient
            handling of time series data. Ussually time series contains a very large number
            if relatively small elements which are ussually acessed in sucessive order. 
            To avoid overhead of loading from the disk each particular time series element, 
            this class group several subsequent time series elements together and store them 
            as single object (block).
            </p><p> 
            As far as C# currently has no templates and
            Perst need to know format of block class, it is responsibity of prgorammer
            to create block implementation derived from TimeSeriesBlock class
            and containing array of time series elements. Size of this array specifies
            the size of the block.
            </p>
            </summary>
        </member>
        <member name="M:Perst.TimeSeries.Add(Perst.TimeSeriesTick)">
            <summary>
            Add new tick to time series
            </summary>
            <param name="tick">new time series element</param>
        </member>
        <member name="M:Perst.TimeSeries.GetEnumerator(System.DateTime,System.DateTime)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>forward iterator within specified range</returns>
        </member>
        <member name="M:Perst.TimeSeries.GetEnumerator(Perst.IterationOrder)">
            <summary>
            Get iterator through all time series elements
            </summary>
            <param name="order">direction of iteration</param>
            <returns>iterator in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.GetEnumerator(System.DateTime,System.DateTime,Perst.IterationOrder)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <param name="order">direction of iteration</param>
            <returns>iterator within specified range in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.Range(System.DateTime,System.DateTime)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>forward iterator within specified range</returns>
        </member>
        <member name="M:Perst.TimeSeries.Range(Perst.IterationOrder)">
            <summary>
            Get iterator through all time series elements
            </summary>
            <param name="order">direction of iteration</param>
            <returns>iterator in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.Range(System.DateTime,System.DateTime,Perst.IterationOrder)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <param name="order">direction of iteration</param>
            <returns>iterator within specified range in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.From(System.DateTime)">
            <summary>
            Get forward iterator for time series elements with timestamp greater or equal than specified
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <returns>forward iterator</returns>
        </member>
        <member name="M:Perst.TimeSeries.Till(System.DateTime)">
            <summary>
            Get backward iterator for time series elements with timestamp less or equal than specified
            </summary>
            <param name="till">inclusive time of the eding of interval</param>
            <returns>backward iterator</returns>
        </member>
        <member name="M:Perst.TimeSeries.Reverse">
            <summary>
            Get backward iterator for time series elements 
            </summary>
            <returns>backward iterator</returns>
        </member>
        <member name="M:Perst.TimeSeries.Contains(System.DateTime)">
            <summary>
            Check if data is available in time series for the specified time
            </summary>
            <param name="timestamp">time series element timestamp</param>
            <returns><code>true</code> if there is element in time series with such timestamp, 
            <code>false</code> otherwise</returns>
        </member>
        <member name="M:Perst.TimeSeries.Remove(System.DateTime,System.DateTime)">
            <summary>
            Remove time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.RemoveFrom(System.DateTime)">
            <summary>
            Remove time series elements with timestamp greater or equal then specified
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.RemoveTill(System.DateTime)">
            <summary>
            Remove time series elements with timestamp less or equal then specified
            </summary>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.RemoveAll">
            <summary>
            Remove all time series elements
            </summary>
            <returns>number of removed elements</returns>
        </member>
        <member name="P:Perst.TimeSeries.FirstTime">
            <summary>
            Get timestamp of first time series element
            </summary>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorClass.KEY_NOT_FOUND) if time series is empy</exception>
        </member>
        <member name="P:Perst.TimeSeries.LastTime">
            <summary>
            Get timestamp of last time series element
            </summary>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorClass.KEY_NOT_FOUND) if time series is empy</exception>
        </member>
        <member name="P:Perst.TimeSeries.Count">
            <summary>
            Get number of elements in time series
            </summary>
        </member>
        <member name="P:Perst.TimeSeries.Item(System.DateTime)">
            <summary> 
            Get tick for specified data
            </summary>
            <param name="timestamp">time series element timestamp</param>
        </member>
        <member name="T:Perst.PersistentString">
            <summary>
            Class encapsulating native .Net string. System.String is not persistent object
            so it can not be stored in Perst as independent persistent object. 
            But sometimes it is needed. This class sole this problem providing implcit conversion
            operator from System.String to PerisstentString.
            Also PersistentString class is mutable, allowing to change it's values.
            </summary>
        </member>
        <member name="M:Perst.PersistentString.#ctor(System.String)">
            <summary>
            Consutrctor of perisstent string
            </summary>
            <param name="str">.Net string</param>
        </member>
        <member name="M:Perst.PersistentString.ToString">
            <summary>
            Get .Net string
            </summary>
            <returns>.Net string</returns>
        </member>
        <member name="M:Perst.PersistentString.Append(System.String)">
            <summary>
            Append string to the current string value of PersistentString
            </summary>
            <param name="tail">appended string</param>
        </member>
        <member name="M:Perst.PersistentString.Set(System.String)">
            <summary>
            Assign new string value to the PersistentString
            </summary>
            <param name="str">new string value</param>
        </member>
        <member name="M:Perst.PersistentString.Get">
            <summary>
            Get current string value
            </summary>
            <returns>.Net string</returns>
        </member>
        <member name="M:Perst.PersistentString.op_Implicit(System.String)~Perst.PersistentString">
            <summary>
            Operator for implicit convertsion from System.String to PersistentString
            </summary>
            <param name="str">.Net string</param>
            <returns>PersistentString</returns>
        </member>
        <member name="M:Perst.PersistentString.op_Implicit(Perst.PersistentString)~System.String">
            <summary>
            Operator for implicit convertsion from PersistentString to System.String
            </summary>
            <param name="str">PersistentString</param>
            <returns>.Net string</returns>
        </member>
        <member name="T:Perst.StorageError">
            <summary> Exception throw by storage implementation
            </summary>
        </member>
        <member name="M:Perst.StorageError.#ctor(Perst.StorageError.ErrorCode)">
            <summary> Get original exception if StorageError excepotion was thrown as the result 
            of catching some other exception within Storage implementation. 
            StorageError is used as wrapper of other exceptions to avoid cascade propagation
            of throws and try/catch constructions.
            </summary>
            <returns>original exception or <code>null</code> if there is no such exception
            
            </returns>
        </member>
        <member name="T:Perst.RectangleR2">
            <summary>
            R2 rectangle class. This class is used in spatial index.
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.Area">
            <summary>
            Rectangle area
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.JoinArea(Perst.RectangleR2,Perst.RectangleR2)">
            <summary>
            Area of covered rectangle for two sepcified rectangles
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.#ctor(Perst.RectangleR2)">
            <summary>
            Create copy of the rectangle
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Construct rectangle with specified coordinates
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.Join(Perst.RectangleR2)">
            <summary>
            Join two rectangles. This rectangle is updates to contain cover of this and specified rectangle.
            </summary>
            <param name="r">rectangle to be joined with this rectangle
            </param>
        </member>
        <member name="M:Perst.RectangleR2.Join(Perst.RectangleR2,Perst.RectangleR2)">
            <summary>
             Non destructive join of two rectangles. 
            </summary>
            <param name="a">first joined rectangle
            </param>
            <param name="b">second joined rectangle
            </param>
            <returns>rectangle containing cover of these two rectangles
            </returns>
        </member>
        <member name="M:Perst.RectangleR2.Intersects(Perst.RectangleR2)">
            <summary>
            Checks if this rectangle intersects with specified rectangle
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.Contains(Perst.RectangleR2)">
            <summary>
            Checks if this rectangle contains the specified rectangle
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.IsEmpty">
            <summary>
            Check if rectanlge is empty 
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Top">
            <summary>
            Smallest Y coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Left">
            <summary>
            Smallest X coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Bottom">
            <summary>
            Greatest Y coordinate  of the rectangle
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Right">
            <summary>
            Greatest X coordinate  of the rectangle
            </summary>
        </member>
        <member name="T:Perst.MarshalByRefPersistent">
            <summary> Base class for persistent capable objects with marshal be reference semantic
            </summary>
        </member>
        <member name="T:Perst.ClassLoader">
            <summary>
            Interface to provide application apecific class loading
            </summary>
        </member>
        <member name="M:Perst.ClassLoader.LoadClass(System.String)">
            <summary>
            Load class with specified name.
            </summary>
            <param name="name">full name of the class to be loaded</param>
            <returns>loaded class or <code>null</code> if class can not be loaded</returns>
        </member>
        <member name="T:Perst.SpatialIndex">
            <summary> Interface of object spatial index.
            Spatial index is used to allow fast selection of spatial objects belonging to the specified rectangle.
            Spatial index is implemented using Guttman R-Tree with quadratic split algorithm.
            </summary>
        </member>
        <member name="M:Perst.SpatialIndex.Get(Perst.Rectangle)">
            <summary>
            Find all objects located in the selected rectangle
            </summary>
            <param name="r">selected rectangle
            </param>
            <returns>array of objects which enveloping rectangle intersects with specified rectangle
            </returns>             
        </member>
        <member name="M:Perst.SpatialIndex.Put(Perst.Rectangle,Perst.IPersistent)">
            <summary>
            Put new object in the index. 
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj"> object associated with this rectangle. Object can be not yet persistent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
        </member>
        <member name="M:Perst.SpatialIndex.Remove(Perst.Rectangle,Perst.IPersistent)">
            <summary>
            Remove object with specified enveloping rectangle from the tree.
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_FOUND) exception if there is no such key in the index
            </exception>
        </member>
        <member name="M:Perst.SpatialIndex.Size">
            <summary>
            Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            </returns>
        </member>
        <member name="M:Perst.SpatialIndex.Clear">
            <summary>
            Remove all objects from the index
            </summary>
        </member>
        <member name="P:Perst.SpatialIndex.Count">
            <summary>
            Get number of objects in the index
            </summary>
        </member>
        <member name="P:Perst.SpatialIndex.WrappingRectangle">
            <summary>
            Get wrapping rectangle 
            </summary>
            <returns>Minimal rectangle containing all rectangles in the index. 
            If index is empty <i>empty rectangle</i> (int.MaxValue, int.MaxValue, int.MinValue, int MinValue)
            is returned.
            </returns>
        </member>
        <member name="T:Perst.PersistentContext">
            <summary>Base class for context bound object with provided
            transparent persistence. Objects derived from this class and marked with
            TransparentPresistence attribute automatically on demand load their 
            content from the database and also automatically detect object modification.
            </summary>
        </member>
        <member name="T:Perst.PersistentComparator">
            <summary> Base class for persistent comparator used in SortedCollection class
            </summary>
        </member>
        <member name="M:Perst.PersistentComparator.CompareMembers(Perst.IPersistent,Perst.IPersistent)">
            <summary> 
            Compare two members of collection
            </summary>
            <param name="m1"> first members</param>
            <param name="m2"> second members</param>
            <returns>negative number if m1 &lt; m2, zero if m1 == m2 and positive number if m1 &gt; m2</returns>
        </member>
        <member name="M:Perst.PersistentComparator.CompareMemberWithKey(Perst.IPersistent,System.Object)">
            <summary>
            Compare member with specified search key
            </summary>
            <param name="mbr"> collection member</param>
            <param name="key"> search key</param>
            <returns>negative number if mbr &lt; key, zero if mbr == key and positive number if mbr &gt; key</returns>
        </member>
        <member name="T:Perst.SpatialIndexR2">
            <summary> Interface of object spatial index.
            Spatial index is used to allow fast selection of spatial objects belonging to the specified rectangle.
            Spatial index is implemented using Guttman R-Tree with quadratic split algorithm.
            </summary>
        </member>
        <member name="M:Perst.SpatialIndexR2.Get(Perst.RectangleR2)">
            <summary>
            Find all objects located in the selected rectangle
            </summary>
            <param name="r">selected rectangle
            </param>
            <returns>array of objects which enveloping rectangle intersects with specified rectangle
            </returns>             
        </member>
        <member name="M:Perst.SpatialIndexR2.Put(Perst.RectangleR2,Perst.IPersistent)">
            <summary>
            Put new object in the index. 
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj"> object associated with this rectangle. Object can be not yet persistent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
        </member>
        <member name="M:Perst.SpatialIndexR2.Remove(Perst.RectangleR2,Perst.IPersistent)">
            <summary>
            Remove object with specified enveloping rectangle from the tree.
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_FOUND) exception if there is no such key in the index
            </exception>
        </member>
        <member name="M:Perst.SpatialIndexR2.Size">
            <summary>
            Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            </returns>
        </member>
        <member name="M:Perst.SpatialIndexR2.Clear">
            <summary>
            Remove all objects from the index
            </summary>
        </member>
        <member name="M:Perst.SpatialIndexR2.Overlaps(Perst.RectangleR2)">
            <summary>
            Get enumerator for objects located in the selected rectangle
            </summary>
            <param name="rect">Selected rectangle</param>
            <returns>enumerable collection for objects which enveloping rectangle overlaps with specified rectangle
            </returns>
        </member>
        <member name="P:Perst.SpatialIndexR2.Count">
            <summary>
            Get number of objects in the index
            </summary>
        </member>
        <member name="P:Perst.SpatialIndexR2.WrappingRectangle">
            <summary>
            Get wrapping rectangle 
            </summary>
            <returns>Minimal rectangle containing all rectangles in the index     
            If index is empty <i>empty rectangle</i> (double.MaxValue, double.MaxValue, double.MinValue, double.MinValue)
            is returned.
            </returns>
        </member>
        <member name="T:Perst.Blob">
            <summary>
            Interface to store/fetch large binary objects
            </summary>
        </member>
        <member name="M:Perst.Blob.GetStream">
            <summary>
            Get stream to fetch/store BLOB data 
            </summary>
            <returns>BLOB read/write stream</returns>
        </member>
        <member name="T:Perst.SortedCollection">
            <summary>
            Interface of sorted collection.
            Sorted collections keeps in members in order specified by comparator.
            Members in the collections can be located using key or range of keys.
            The SortedCollection is efficient container of objects for in-memory databases.
            For databases which size is significatly larger than size of page pool, operation with SortedList
            can cause trashing and so very bad performance. Unlike other index structures SortedCollection
            doesn't store values of keys and so search in the collection requires fetching of its members.
            </summary>
        </member>
        <member name="M:Perst.SortedCollection.Get(System.Object)">
             <summary>
             Get member with specified key.
             </summary>
             <param name="key"> specified key. It should match with type of the index and should be inclusive.</param>
             <returns> object with this value of the key or <code>null</code> if key nmot found</returns>
             <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_UNIQUE) exception if there are more than 
             one objects in the collection with specified value of the key.  
             </exception>
            
        </member>
        <member name="M:Perst.SortedCollection.Get(System.Object,System.Object)">
             <summary>
             Get members which key value belongs to the specified range.
             Either from boundary, either till boundary either both of them can be <code>null</code>.
             In last case the method returns all objects from the collection.
             </summary>
             <param name="from"> low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive. </param>
             <param name="till"> high boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive. </param>
             <returns> array of objects which keys belongs to the specified interval, ordered by key value</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Add(Perst.IPersistent)">
             <summary>
             Add new member to collection
             </summary>
             <param name="obj"> new member</param>
             <returns> <code>true</code> if object is successfully added in the index, 
             <code>false</code> if collection was declared as unique and there is already member with such value
             of the key in the collection. </returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Contains(Perst.IPersistent)">
             <summary>
             Check if collections contains specified member
             </summary>
             <returns> <code>true</code> if specified member belongs to the collection</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Remove(Perst.IPersistent)">
             <summary>
             Remove member from collection
             </summary>
             <param name="obj"> member to be removed</param>
             <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_FOUND) exception if there is no such key in the collection</exception>
            
        </member>
        <member name="M:Perst.SortedCollection.Size">
             <summary>
             Get number of objects in the collection
             </summary>
             <returns> number of objects in the collection</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Clear">
             <summary>
             Remove all objects from the collection
             </summary>
            
        </member>
        <member name="M:Perst.SortedCollection.ToArray">
             <summary>
             Get all objects in the index as array ordered by index key.
             </summary>
             <returns> array of objects in the index ordered by key value</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.ToArray(System.Type)">
            <summary> Get all objects in the index as array of specified type orderd by index key
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.SortedCollection.GetEnumerator(System.Object,System.Object)">
             <summary>
             Get iterator for traversing collection members  with key belonging to the specified range. 
             </summary>
             <param name="from"> low boundary. If <code>null</code> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till"> high boundary. If <code>null</code> then high boundary is not specified.
             High boundary can be inclusive or exclusive. </param>
             <returns> selection iterator</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.GetComparator">
             <summary>
             Get comparator used in this collection
             </summary>
             <returns> collection comparator</returns>
            
        </member>
        <member name="P:Perst.SortedCollection.Item(System.Object)">
            <summary> Access element by key
            </summary>
        </member>
        <member name="P:Perst.SortedCollection.Item(System.Object,System.Object)">
            <summary> Access elements by key range
            </summary>
        </member>
        <member name="T:Perst.Rectangle">
            <summary>
            Rectangle with integer coordinates. This class is used in spatial index.
            </summary>
        </member>
        <member name="M:Perst.Rectangle.Area">
            <summary>
            Rectangle area
            </summary>
        </member>
        <member name="M:Perst.Rectangle.JoinArea(Perst.Rectangle,Perst.Rectangle)">
            <summary>
            Area of covered rectangle for two sepcified rectangles
            </summary>
        </member>
        <member name="M:Perst.Rectangle.#ctor(Perst.Rectangle)">
            <summary>
            Create copy of the rectangle
            </summary>
        </member>
        <member name="M:Perst.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct rectangle with specified coordinates
            </summary>
        </member>
        <member name="M:Perst.Rectangle.Join(Perst.Rectangle)">
            <summary>
            Join two rectangles. This rectangle is updates to contain cover of this and specified rectangle.
            </summary>
            <param name="r">rectangle to be joined with this rectangle
            </param>
        </member>
        <member name="M:Perst.Rectangle.Join(Perst.Rectangle,Perst.Rectangle)">
            <summary>
             Non destructive join of two rectangles. 
            </summary>
            <param name="a">first joined rectangle
            </param>
            <param name="b">second joined rectangle
            </param>
            <returns>rectangle containing cover of these two rectangles
            </returns>
        </member>
        <member name="M:Perst.Rectangle.Intersects(Perst.Rectangle)">
            <summary>
            Checks if this rectangle intersects with specified rectangle
            </summary>
        </member>
        <member name="M:Perst.Rectangle.Contains(Perst.Rectangle)">
            <summary>
            Checks if this rectangle contains the specified rectangle
            </summary>
        </member>
        <member name="M:Perst.Rectangle.IsEmpty">
            <summary>
            Check if rectanlge is empty 
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Top">
            <summary>
            Smallest Y coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Left">
            <summary>
            Smallest X coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Bottom">
            <summary>
            Greatest Y coordinate  of the rectangle
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Right">
            <summary>
            Greatest X coordinate  of the rectangle
            </summary>
        </member>
        <member name="T:Perst.ISet">
            <summary>
             Interface of objects set
             </summary>
        </member>
        <member name="M:Perst.ISet.Contains(Perst.IPersistent)">
            <summary>
            Check if set contains specified element
            </summary>
            <param name="o">checked element</param>
            <returns><code>true</code> if elementis in set</returns>
        </member>
        <member name="M:Perst.ISet.ContainsAll(System.Collections.IEnumerator)">
            <summary>
            Check if the set contains all members from specified enumerator
            </summary>
            <param name="e">enumerator specifying members</param>
            <returns><code>true</code> if all members of enumerator are present in the set</returns>
        </member>
        <member name="M:Perst.ISet.ContainsAll(System.Collections.IEnumerable)">
            <summary>
            Check if the set contains all members from specified collection
            </summary>
            <param name="e">collection specifying members</param>
            <returns><code>true</code> if all members of collection are present in the set</returns>
        </member>
        <member name="M:Perst.ISet.Add(Perst.IPersistent)">
            <summary>
            Add new element to the set
            </summary>
            <param name="o">element to be added</param>
            <returns><code>true</code> if element was successfully added, 
            <code>false</code> if element is already in the set</returns>
        </member>
        <member name="M:Perst.ISet.AddAll(System.Collections.IEnumerator)">
            <summary>
            Add all elements from specified enumerator to the set
            </summary>
            <param name="e">enumerator specifying members</param>
            <returns><code>true</code> if at least one element was added to the set,
            <code>false</code> if now new elements were added</returns>
        </member>
        <member name="M:Perst.ISet.AddAll(System.Collections.IEnumerable)">
            <summary>
            Add all elements from specified collection to the set
            </summary>
            <param name="e">collection specifying members</param>
            <returns><code>true</code> if at least one element was added to the set,
            <code>false</code> if now new elements were added</returns>
        </member>
        <member name="M:Perst.ISet.Remove(Perst.IPersistent)">
            <summary>
            Remove element from the set
            </summary>
            <param name="o">removed element</param>
            <returns><code>true</code> if element was successfully removed,
            <code>false</code> if there is not such element in the set</returns>
        </member>
        <member name="M:Perst.ISet.RemoveAll(System.Collections.IEnumerator)">
            <summary>
            Remove from the set all members from the specified enumerator
            </summary>
            <param name="c">enumerator specifying members to be removed from the set</param>
            <returns></returns>
        </member>
        <member name="M:Perst.ISet.RemoveAll(System.Collections.IEnumerable)">
            <summary>
            Remove from the set all members from the specified collection
            </summary>
            <param name="c">collection specifying members to be removed from the set</param>
            <returns></returns>
        </member>
        <member name="M:Perst.ISet.ToArray">
            <summary>
            Copy all set members to an array
            </summary>
            <returns>array of object with set members</returns>
        </member>
        <member name="M:Perst.ISet.ToArray(System.Type)">
            <summary>
            Copy all set members to an array of specified type
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of specified type with members of the set</returns>
        </member>
        <member name="T:Perst.Storage">
            <summary> Object storage
            </summary>
        </member>
        <member name="F:Perst.Storage.INFINITE_PAGE_POOL">
            <summary> 
            Constant specifying that page pool should be dynamically extended 
            to conatins all database file pages
            </summary>
        </member>
        <member name="F:Perst.Storage.DEFAULT_PAGE_POOL_SIZE">
            <summary>
            Constant specifying default pool size
            </summary>
        </member>
        <member name="M:Perst.Storage.Open(System.String,System.Int32)">
            <summary> Open the storage
            </summary>
            <param name="filePath">path to the database file
            </param>
            <param name="pagePoolSize">size of page pool (in bytes). Page pool should contain
            at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
            But larger page pool ussually leads to better performance (unless it could not fit
            in memory and cause swapping).
            
            </param>
        </member>
        <member name="M:Perst.Storage.Open(System.String)">
            <summary> Open the storage with default page pool size
            </summary>
            <param name="filePath">path to the database file
            
            </param>
        </member>
        <member name="M:Perst.Storage.IsInMemory">
            <summary>
            INdicates that data is transient, no need to store to disk
            </summary>
            <returns></returns>
        </member>
        <member name="M:Perst.Storage.Open(Perst.IFile,System.Int32)">
            <summary> Open the storage
            </summary>
            <param name="file">user specific implementation of IFile interface
            </param>
            <param name="pagePoolSize">size of page pool (in bytes). Page pool should contain
            at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
            But larger page pool ussually leads to better performance (unless it could not fit
            in memory and cause swapping).
            
            </param>
        </member>
        <member name="M:Perst.Storage.Open(Perst.IFile)">
            <summary> Open the storage with default page pool size
            </summary>
            <param name="file">user specific implementation of IFile interface
            </param>
        </member>
        <member name="M:Perst.Storage.Open(System.String,System.Int32,System.String)">
            <summary> Open the encrypted storage
            </summary>
            <param name="filePath">path to the database file
            </param>
            <param name="pagePoolSize">size of page pool (in bytes). Page pool should contain
            at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
            But larger page pool ussually leads to better performance (unless it could not fit
            in memory and cause swapping).
            </param>
            <param name="cipherKey">cipher key</param>
        </member>
        <member name="M:Perst.Storage.IsOpened">
            <summary>Check if database is opened
            </summary>
            <returns><code>true</code> if database was opened by <code>open</code> method, 
            <code>false</code> otherwise
            </returns>        
        </member>
        <member name="M:Perst.Storage.Commit">
            <summary> Commit changes done by the last transaction. Transaction is started implcitlely with forst update
            opertation.
            </summary>
        </member>
        <member name="M:Perst.Storage.Rollback">
            <summary> Rollback changes made by the last transaction
            </summary>
        </member>
        <member name="M:Perst.Storage.Backup(System.IO.Stream)">
            <summary>
            Backup current state of database
            </summary>
            <param name="stream">output stream to which backup is done</param>
        </member>
        <member name="M:Perst.Storage.CreateIndex(System.Type,System.Boolean)">
            <summary> Create new index
            </summary>
            <param name="type">type of the index key (you should path here <code>String.class</code>, 
            <code>int.class</code>, ...)
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.UNSUPPORTED_INDEX_TYPE) exception if 
            specified key type is not supported by implementation.
            
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateFieldIndex(System.Type,System.String,System.Boolean)">
            <summary> 
            Create new field index
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldName">name of the index field. Field with such name should be present in specified class <code>type</code>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateFieldIndex(System.Type,System.String[],System.Boolean)">
            <summary> 
            Create new multi-field index
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldNames">array of names of the fields. Field with such name should be present in specified class <code>type</code>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateSpatialIndex">
            <summary>
            Create new spatial index with integer coordinates
            </summary>
            <returns>
            persistent object implementing spatial index
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateSpatialIndexR2">
            <summary>
            Create new R2 spatial index
            </summary>
            <returns>
            persistent object implementing spatial index
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateSortedCollection(Perst.PersistentComparator,System.Boolean)">
            <summary>
            Create new sorted collection with specified comparator
            </summary>
            <param name="comparator">comparator class specifying order in the collection</param>
            <param name="unique"> whether collection is unique (members with the same key value are not allowed)</param>
            <returns> persistent object implementing sorted collection</returns>
        </member>
        <member name="M:Perst.Storage.CreateSortedCollection(System.Boolean)">
            <summary>
            Create new sorted collection. Members of this collections should implement 
            <code>System.IComparable</code> interface and make it possible to compare 
            collection members with each other as well as with serch key.
            </summary>
            <param name="unique"> whether collection is unique (members with the same key value are not allowed)</param>
            <returns> persistent object implementing sorted collection</returns>
        </member>
        <member name="M:Perst.Storage.CreateSet">
            <summary>
            Create new object set
            </summary>
            <returns>
            empty set of persistent objects
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateLink">
            <summary> Create one-to-many link.
            </summary>
            <returns>new empty link, new members can be added to the link later.
            
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateLink(System.Int32)">
            <summary> Create one-to-many link with specified initial size.
            </summary>
            <param name="intialSize">initial size of the array</param>
            <returns>new empty link, new members can be added to the link later.
            
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateRelation(Perst.IPersistent)">
            <summary> Create relation object. Unlike link which represent embedded relation and stored
            inside owner object, this Relation object is standalone persisitent object
            containing references to owner and members of the relation
            </summary>
            <param name="owner">owner of the relation
            </param>
            <returns>object representing empty relation (relation with specified owner and no members), 
            new members can be added to the link later.
            
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateBlob">
            <summary>
            Create new BLOB. Create object for storing large binary data.
            </summary>
            <returns>empty BLOB</returns>
        </member>
        <member name="M:Perst.Storage.CreateTimeSeries(System.Type,System.Int64)">
            <summary>
            Create new time series object. 
            </summary>
            <param name="blockClass">class derived from TimeSeriesBlock</param>
            <param name="maxBlockTimeInterval">maximal difference in system ticks (100 nanoseconds) between timestamps 
            of the first and the last elements in a block. 
            If value of this parameter is too small, then most blocks will contains less elements 
            than preallocated. 
            If it is too large, then searching of block will be inefficient, because index search 
            will select a lot of extra blocks which do not contain any element from the 
            specified range.
            Usually the value of this parameter should be set as
            (number of elements in block)*(tick interval)*2. 
            Coefficient 2 here is used to compencate possible holes in time series.
            For example, if we collect stocks data, we will have data only for working hours.
            If number of element in block is 100, time series period is 1 day, then
            value of maxBlockTimeInterval can be set as 100*(24*60*60*10000000L)*2
            </param>
            <returns>new empty time series</returns>
        </member>
        <member name="M:Perst.Storage.CreatePatriciaTrie">
             <summary>
             Create PATRICIA trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric)
             Tries are a kind of tree where each node holds a common part of one or more keys. 
             PATRICIA trie is one of the many existing variants of the trie, which adds path compression 
             by grouping common sequences of nodes together.
             This structure provides a very efficient way of storing values while maintaining the lookup time 
             for a key in O(N) in the worst case, where N is the length of the longest key. 
             This structure has it's main use in IP routing software, but can provide an interesting alternative 
             to other structures such as hashtables when memory space is of concern.
             </summary>
             <returns>created PATRICIA trie</returns>
            
        </member>
        <member name="M:Perst.Storage.Close">
            <summary> Commit transaction (if needed) and close the storage
            </summary>
        </member>
        <member name="M:Perst.Storage.SetGcThreshold(System.Int64)">
             <summary> Set threshold for initiation of garbage collection. By default garbage collection is disable (threshold is set to
             Int64.MaxValue). If it is set to the value different fro Long.MAX_VALUE, GC will be started each time when
             delta between total size of allocated and deallocated objects exceeds specified threashold OR
             after reaching end of allocation bitmap in allocator. 
             </summary>
             <param name="allocatedDelta"> delta between total size of allocated and deallocated object since last GC or storage opening
             </param>
            
        </member>
        <member name="M:Perst.Storage.Gc">
            <summary>Explicit start of garbage collector
            </summary>
            <returns>number of collected (deallocated) objects</returns>
            
        </member>
        <member name="M:Perst.Storage.ExportXML(System.IO.StreamWriter)">
            <summary> Export database in XML format 
            </summary>
            <param name="writer">writer for generated XML document
            
            </param>
        </member>
        <member name="M:Perst.Storage.ImportXML(System.IO.StreamReader)">
            <summary> Import data from XML file
            </summary>
            <param name="reader">XML document reader
            
            </param>
        </member>
        <member name="M:Perst.Storage.GetObjectByOID(System.Int32)">
            <summary> 
            Retrieve object by OID. This method should be used with care because
            if object is deallocated, its OID can be reused. In this case
            getObjectByOID will return reference to the new object with may be
            different type.
            </summary>
            <param name="oid">object oid</param>
            <returns>reference to the object with specified OID</returns>
        </member>
        <member name="M:Perst.Storage.SetProperty(System.String,System.Object)">
            
             <summary>
             Set database property. This method should be invoked before opening database. 
             </summary>
             <remarks> 
             Currently the following boolean properties are supported:
             <TABLE><TR><TH>Property name</TH><TH>Parameter type</TH><TH>Default value</TH><TH>Description</TH></TR>
             <TR><TD><code>perst.serialize.transient.objects</code></TD><TD>bool</TD><TD>false</TD>
             <TD>Serialize any class not derived from IPersistent or IValue using standard Java serialization
             mechanism. Packed object closure is stored in database as byte array. Latter the same mechanism is used
             to unpack the objects. To be able to use this mechanism, object and all objects referenced from it
             should be marked with Serializable attribute and should not contain references
             to persistent objects. If such object is referenced from N persistent object, N instances of this object
             will be stored in the database and after loading there will be N instances in memory.
             </TD></TR>
             <TR><TD><code>perst.object.cache.init.size</code></TD><TD>int</TD><TD>1319</TD>
             <TD>Initial size of object cache
             </TD></TR>
             <TR><TD><code>perst.object.cache.kind</code></TD><TD>String</TD><TD>"lru"</TD>
             <TD>Kind of object cache. The following values are supported:
             "strong", "weak", "lru". <B>Strong</B> cache uses strong (normal)                                                                         
             references to refer persistent objects. Thus none of loaded persistent objects                                                                                                                                         
             can be deallocated by GC. <B>Weak</B> and <b>lru</b> caches use weak references. 
             But <b>lru</b> cache also pin some number of recently used objects.
             </TD></TR>
             <TR><TD><code>perst.object.index.init.size</code></TD><TD>int</TD><TD>1024</TD>
             <TD>Initial size of object index (specifying large value increase initial size of database, but reduce
             number of index reallocations)
             </TD></TR>
             <TR><TD><code>perst.extension.quantum</code></TD><TD>long</TD><TD>1048576</TD>
             <TD>Object allocation bitmap extension quantum. Memory is allocate by scanning bitmap. If there is no
             large enough hole, then database is extended by the value of dbDefaultExtensionQuantum. 
             This parameter should not be smaller than 64Kb.
             </TD></TR>
             <TR><TD><code>perst.gc.threshold</code></TD><TD>long</TD><TD>long.MaxValue</TD>
             <TD>Threshold for initiation of garbage collection. 
             If it is set to the value different from long.MaxValue, GC will be started each time 
             when delta between total size of allocated and deallocated objects exceeds specified threashold OR                                                                                                                                                                                                                           
             after reaching end of allocation bitmap in allocator.
             </TD></TR>
             <TR><TD><code>perst.code.generation</code></TD><TD>bool</TD><TD>true</TD>
             <TD>enable or disable dynamic generation of pack/unpack methods for persistent 
             classes. Such methods can be generated only for classes with public fields.
             Using generated methods instead of .Net reflection API increase speed of
             object store/fetch operations, but generation itself takes additional time at 
             startup 
             </TD></TR>
             <TR><TD><code>perst.file.readonly</code></TD><TD>bool</TD><TD>false</TD>
             <TD>Database file should be opened in read-only mode.
             </TD></TR>
             <TR><TD><code>perst.file.noflush</code></TD><TD>bool</TD><TD>false</TD>
             <TD>To not flush file during transaction commit. It will greatly increase performance because
             eliminate synchronous write to the disk (when program has to wait until all changed
             are actually written to the disk). But it can cause database corruption in case of 
             OS or power failure (but abnormal termination of application itself should not cause
             the problem, because all data which were written to the file, but is not yet saved to the disk is 
             stored in OS file buffers and sooner or later them will be written to the disk)
             </TD></TR>
             <TR><TD><code>perst.alternative.btree</code></TD><TD>bool</TD><TD>false</TD>
             <TD>Use aternative implementation of B-Tree (not using direct access to database
             file pages). This implementation should be used in case of serialized per thread transctions.
             New implementation of B-Tree will be used instead of old implementation
             if "perst.alternative.btree" property is set. New B-Tree has incompatible format with 
             old B-Tree, so you could not use old database or XML export file with new indices. 
             Alternative B-Tree is needed to provide serializable transaction (old one could not be used).
             Also it provides better performance (about 3 times comaring with old implementation) because
             of object caching. And B-Tree supports keys of user defined types. 
             </TD></TR>
             <TR><TD><code>perst.background.gc</code></TD><TD>bool</TD><TD>false</TD>
             <TD>Perform garbage collection in separate thread without blocking the main application.                                                                                          
             </TD></TR>
             <TR><TD><code>perst.string.encoding</code></TD><TD>String</TD><TD>null</TD>
             <TD>Specifies encoding of storing strings in the database. By default Perst stores 
             strings as sequence of chars (two bytes per char). If all strings in application are in 
             the same language, then using encoding  can signifficantly reduce space needed
             to store string (about two times). But please notice, that this option has influence
             on all strings  stored in database. So if you already have some data in the storage
             and then change encoding, then it can cause incorrect fetching of strings and even database crash.
             </TD></TR>
             </TABLE>
             </remarks>
             <param name="name">name of the property</param>
             <param name="val">value of the property</param>
            
        </member>
        <member name="M:Perst.Storage.SetProperties(System.Collections.Specialized.NameValueCollection)">
            
             <summary>Set database properties. This method should be invoked before opening database. 
             For list of supported properties please see <see cref="M:Perst.Storage.SetProperty(System.String,System.Object)">setProperty</see>. 
             All not recognized properties are ignored.
             </summary>
             <param name="props">collections with storage properties</param>
            
        </member>
        <member name="M:Perst.Storage.SetListener(Perst.StorageListener)">
             <summary>
             Set storage listener.
             </summary>summary>
             <param name="listener">new storage listener (may be null)</param>
             <returns>previous storage listener</returns>
            
        </member>
        <member name="M:Perst.Storage.BeginThreadTransaction(Perst.TransactionMode)">
            <summary>
            Begin per-thread transaction. Three types of per-thread transactions are supported: 
            exclusive, cooperative and serializable. In case of exclusive transaction, only one 
            thread can update the database. In cooperative mode, multiple transaction can work 
            concurrently and commit() method will be invoked only when transactions of all threads
            are terminated. Serializable transactions can also work concurrently. But unlike
            cooperative transaction, the threads are isolated from each other. Each thread
            has its own associated set of modified objects and committing the transaction will cause
            saving only of these objects to the database.To synchronize access to the objects
            in case of serializable transaction programmer should use lock methods
            of IResource interface. Shared lock should be set before read access to any object, 
            and exclusive lock - before write access. Locks will be automatically released when
            transaction is committed (so programmer should not explicitly invoke unlock method)
            In this case it is guaranteed that transactions are serializable.
            It is not possible to use <code>IPersistent.store()</code> method in
            serializable transactions. That is why it is also not possible to use Index and FieldIndex
            containers (since them are based on B-Tree and B-Tree directly access database pages
            and use <code>store()</code> method to assign OID to inserted object. 
            You should use <code>SortedCollection</code> based on T-Tree instead or alternative
            B-Tree implemenataion (set "perst.alternative.btree" property).
            </summary>
            <param name="mode"><code>TransactionMode.Exclusive</code>,  <code>TransactionMode.Cooperative</code> or <code>TransactionMode.Serializable</code>
            </param>
        </member>
        <member name="M:Perst.Storage.EndThreadTransaction">
            <summary>
            End per-thread transaction started by beginThreadTransaction method.
            <ul>
            <li>If transaction is <i>exclusive</i>, this method commits the transaction and
            allows other thread to proceed.</li><li>
            If transaction is <i>serializable</i>, this method commits sll changes done by this thread
            and release all locks set by this thread.</li><li>     
            If transaction is <i>cooperative</i>, this method decrement counter of cooperative
            transactions and if it becomes zero - commit the work</li></ul>
            </summary>
        </member>
        <member name="M:Perst.Storage.EndThreadTransaction(System.Int32)">
            <summary>
            End per-thread cooperative transaction with specified maximal delay of transaction
            commit. When cooperative transaction is ended, data is not immediately committed to the
            disk (because other cooperative transaction can be active at this moment of time).
            Instead of it cooperative transaction counter is decremented. Commit is performed
            only when this counter reaches zero value. But in case of heavy load there can be a lot of
            requests and so a lot of active cooperative transactions. So transaction counter never reaches zero value.
            If system crash happens a large amount of work will be lost in this case. 
            To prevent such scenario, it is possible to specify maximal delay of pending transaction commit.
            In this case when such timeout is expired, new cooperative transaction will be blocked until
            transaction is committed.
            </summary>
            <param name="maxDelay">maximal delay in milliseconds of committing transaction.  Please notice, that Perst could 
            not force other threads to commit their cooperative transactions when this timeout is expired. It will only
            block new cooperative transactions to make it possible to current transaction to complete their work.
            If <code>maxDelay</code> is 0, current thread will be blocked until all other cooperative trasnaction are also finished
            and changhes will be committed to the database.
            </param>
        </member>
        <member name="M:Perst.Storage.RollbackThreadTransaction">
            <summary>
            Rollback per-thread transaction. It is safe to use this method only for exclusive transactions.
            In case of cooperative transactions, this method rollback results of all transactions.
            </summary>
        </member>
        <member name="M:Perst.Storage.GetMemoryDump">
            <summary>
            Get database memory dump. This function returns hashmap which key is classes
            of stored objects and value - MemoryUsage object which specifies number of instances
            of particular class in the storage and total size of memory used by these instance.
            Size of internal database structures (object index, memory allocation bitmap) is associated with 
            <code>Storage</code> class. Size of class descriptors  - with <code>System.Type</code> class.
            <p>This method traverse the storage as garbage collection do - starting from the root object
            and recursively visiting all reachable objects. So it reports statistic only for visible objects.
            If total database size is significantly larger than total size of all instances reported
            by this method, it means that there is garbage in the database. You can explicitly invoke
            garbage collector in this case.</p> 
            </summary>
        </member>
        <member name="P:Perst.Storage.Root">
            <summary> Get/set storage root. Storage can have exactly one root object. 
            If you need to have several root object and access them by name (as is is possible 
            in many other OODBMSes), you should create index and use it as root object.
            Previous reference to the root object is rewritten but old root is not automatically deallocated.
            </summary>
        </member>
        <member name="P:Perst.Storage.Loader">
            <summary>
            Set class loader. This class loader will be used to locate classes for 
            loaded class descriptors. If class loader is not specified or
            it did find the class, then class will be searched in all active assemblies
            </summary>
        </member>
        <member name="P:Perst.Storage.UsedSize">
            <summary>
            Get total size of all allocated objects in the database
            </summary>
        </member>
        <member name="P:Perst.Storage.DatabaseSize">
            <summary>
            Get size of the database
            </summary>
        </member>
        <member name="T:Perst.XMLImportException">
            <summary> Exception thrown during import of data from XML file in database
            </summary>
        </member>
        <member name="T:Perst.PatriciaTrieKey">
             
             Convert different type of keys to 64-bit long value used in PATRICIA trie 
             (Practical Algorithm To Retrieve Information Coded In Alphanumeric)
            
        </member>
        <member name="F:Perst.PatriciaTrieKey.mask">
            
             Bit mask representing bit vector.
             The last digit of the key is the right most bit of the mask
            
        </member>
        <member name="F:Perst.PatriciaTrieKey.length">
            
             Length of bit vector (can not be larger than 64)
            
        </member>
        <member name="T:Perst.TimeSeriesTick">
            <summary>
            Interface for timeseries element.
            You should derive your time series element from this class
            and implement Time getter method.
            </summary>
        </member>
        <member name="P:Perst.TimeSeriesTick.Time">
            <summary>
            Get time series element timestamp (100 nanoseconds)
            </summary>
        </member>
        <member name="T:Perst.TimeSeriesBlock">
            <summary>
            Abstract base class for time series block.
            Progammer has to define its own block class derived from this class
            containign array of time series elements and providing accessors to the array elements 
            and Ticks getter method to access this whole array.
            </summary>
        </member>
        <member name="P:Perst.TimeSeriesBlock.Ticks">
            <summary>
            Get time series elements stored in this block.
            Returns preallocated array of time series element. Only <code>used</code>
            items of this array actually contains time series elements.
            </summary>
        </member>
        <member name="P:Perst.TimeSeriesBlock.Item(System.Int32)">
            <summary>
            Array elements accessor. 
            </summary>
        </member>
        <member name="T:Perst.StorageListener">
            <summary>
            Listener of database events. Programmer should derive his own subclass and register
            it using Storage.setListener method.
            </summary>
        </member>
        <member name="M:Perst.StorageListener.DatabaseCorrupted">
            <summary>
            This metod is called during database open when database was not
            close normally and has to be recovered
            </summary>
        </member>
        <member name="M:Perst.StorageListener.RecoveryCompleted">
            <summary>
            This method is called after completion of recovery
            </summary>
        </member>
        <member name="M:Perst.StorageListener.GcStarted">
            <summary>
            This method is called when garbage collection is  started (ether explicitly
            by invocation of Storage.gc() method, either implicitly  after allocation
            of some amount of memory)).
            </summary>
        </member>
        <member name="M:Perst.StorageListener.DeallocateObject(System.Type,System.Int32)">
             <summary>
             This method is called  when unreferenced object is deallocated from 
             database. It is possible to get instance of the object using
             <code>Storage.getObjectByOid()</code> method.
             </summary>
             <param name="cls">class of deallocated object</param>
             <param name="oid">object identifier of deallocated object</param>
            
        </member>
        <member name="M:Perst.StorageListener.GcCompleted(System.Int32)">
             <summary>
             This method is called when garbage collection is completed
             </summary>
             <param name="nDeallocatedObjects">number of deallocated objects</param>
            
        </member>
        <member name="T:Perst.Impl.CodeGenerator">
            <summary>
            Generate code for condition
            </summary>
        </member>
        <member name="T:Perst.StorageFactory">
            <summary> Storage factory
            </summary>
        </member>
        <member name="M:Perst.StorageFactory.CreateStorage">
            <summary> Create new instance of the storage
            </summary>
            <param name="new">instance of the storage (unopened,you should explicitely invoke open method)
            
            </param>
        </member>
        <member name="P:Perst.StorageFactory.Instance">
            <summary> Get instance of storage factory.
            So new storages should be create in application in the following way:
            <code>StorageFactory.Instance.createStorage()</code>
            </summary>
        </member>
        <member name="T:Perst.Projection">
            <summary>
            Class use to project selected objects using relation field. 
            For all selected objects (specified by array ort iterator), 
            value of specified field (of IPersistent, array of IPersistent, Link or Relation type)
            is inspected and all referenced object for projection (duplicate values are eliminated)
            </summary>
        </member>
        <member name="M:Perst.Projection.#ctor(System.Type,System.String)">
            <summary>
            Constructor of projection specified by class and field name of projected objects
            </summary>
            <param name="type">base class for selected objects</param>
            <param name="fieldName">field name used to perform projection</param>
        </member>
        <member name="M:Perst.Projection.#ctor">
            <summary>
            Default constructor of projection. This constructor should be used
            only when you are going to derive your class from Projection and redefine
            map method in it or sepcify type and fieldName later using setProjectionField
            method
            </summary>
        </member>
        <member name="M:Perst.Projection.SetProjectionField(System.Type,System.String)">
            <summary>
            Specify class of the projected objects and projection field name
            </summary>
            <param name="type">base class for selected objects</param>
            <param name="fieldName">field name used to perform projection</param>
        </member>
        <member name="M:Perst.Projection.Project(Perst.IPersistent[])">
            <summary>
            Project specified selection
            </summary>
            <param name="selection">array with selected object</param>
        </member>
        <member name="M:Perst.Projection.Project(Perst.IPersistent)">
            <summary>
            Project specified object
            </summary>
            <param name="obj">selected object</param>
        </member>
        <member name="M:Perst.Projection.Project(System.Collections.IEnumerator)">
            <summary>
            Project specified selection
            </summary>
            <param name="selection">enumerator specifying selceted objects</param>
        </member>
        <member name="M:Perst.Projection.Project(System.Collections.IEnumerable)">
            <summary>
            Project specified selection
            </summary>
            <param name="selection">enumerator specifying selceted objects</param>
        </member>
        <member name="M:Perst.Projection.Join(Perst.Projection)">
            <summary>
            Join this projection with another projection.
            Result of this join is set of objects present in both projections.
            </summary>
            <param name="prj">joined projection</param>
        </member>
        <member name="M:Perst.Projection.ToArray">
            <summary>
            Get result of preceding project and join operations
            </summary>
            <returns>array of objects</returns>
        </member>
        <member name="M:Perst.Projection.ToArray(System.Type)">
            <summary>
            Get result of preceding project and join operations
            </summary>
            <param name="elemType">type of result array element</param>
            <returns>array of objects</returns>
        </member>
        <member name="M:Perst.Projection.GetEnumerator">
            <summary>
            Get enumerator for result of preceding project and join operations
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Perst.Projection.Reset">
            <summary>
            Reset projection - clear result of prceding project and join operations
            </summary>
        </member>
        <member name="M:Perst.Projection.Add(Perst.IPersistent)">
            <summary>
            Add object to the set
            </summary>
            <param name="obj">object to be added to the set</param>
        </member>
        <member name="M:Perst.Projection.Map(Perst.IPersistent)">
            <summary>
            Get related objects for the object obj. 
            It is possible to redifine this method in derived classes 
            to provide application specific mapping
            </summary>
            <param name="obj">object from the selection</param>
        </member>
        <member name="P:Perst.Projection.Length">
            <summary>
            Get number of objets in the result 
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDefaultInitIndexSize">
            <summary> Initialial database index size - increasing it reduce number of inde reallocation but increase
            initial database size. Should be set before openning connection.
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDefaultObjectCacheInitSize">
            <summary> Initial capacity of object hash
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDefaultExtensionQuantum">
            <summary> Database extension quantum. Memory is allocate by scanning bitmap. If there is no
            large enough hole, then database is extended by the value of dbDefaultExtensionQuantum 
            This parameter should not be smaller than dbFirstUserId
            </summary>
        </member>
        <member name="T:Perst.NullFile">
            <summary>
            This implementation of <code>IFile</code> interface can be used
            to make Perst an main-memory database. It should be used when pagePoolSize
            is set to <code>Storage.INFINITE_PAGE_POOL</code>. In this case all pages are cached in memory
            and <code>NullFile</code> is used just as a stub.
            <code>NullFile</code> should be used only when data is transient - i.e. it should not be saved
            between database sessions. If you need in-memory database but which provide data persistency, 
            you should use normal file and infinite page pool size. 
            </summary>
        </member>
        <member name="T:Perst.L2List">
            <summary>
            Double linked list.
            </summary>
        </member>
        <member name="T:Perst.L2ListElem">
            <summary>
            Double linked list element.
            </summary>
        </member>
        <member name="M:Perst.L2ListElem.Prune">
            <summary>
            Make list empty. 
            This method should be applied to list header. 
            </summary>
        </member>
        <member name="M:Perst.L2ListElem.LinkAfter(Perst.L2ListElem)">
            <summary>
            Link specified element in the list after this element
            </summary>
        </member>
        <member name="M:Perst.L2ListElem.LinkBefore(Perst.L2ListElem)">
            <summary>
            Link specified element in the list before this element
            </summary>
        </member>
        <member name="M:Perst.L2ListElem.Unlink">
            <summary>
            Remove element from the list
            </summary>
        </member>
        <member name="P:Perst.L2ListElem.Next">
            <summary>
            Get next list element. 
            Been call for the last list element, this method will return first element of the list 
            or list header
            </summary>
        </member>
        <member name="P:Perst.L2ListElem.Prev">
            <summary>
            Get previous list element. 
            Been call for the first list element, this method will return last element of the list 
            or list header
            </summary>
        </member>
        <member name="M:Perst.L2List.Clear">
            <summary>
            Make list empty. 
            </summary>
        </member>
        <member name="M:Perst.L2List.Prepend(Perst.L2ListElem)">
            <summary>
            Insert element at the beginning of the list
            </summary>
        </member>
        <member name="M:Perst.L2List.Append(Perst.L2ListElem)">
            <summary>
            Insert element at the end of the list
            </summary>
        </member>
        <member name="M:Perst.L2List.Remove(Perst.L2ListElem)">
            <summary>
            Remove element from the list
            </summary>
        </member>
        <member name="M:Perst.L2List.Add(Perst.L2ListElem)">
            <summary>
            Add element to the list
            </summary>
        </member>
        <member name="P:Perst.L2List.Head">
            <summary>
            Get list head element
            </summary>
            <returns>list head element or null if list is empty
            </returns>>
        </member>
        <member name="P:Perst.L2List.Tail">
            <summary>
            Get list tail element
            </summary>
            <returns>list tail element or null if list is empty
            </returns>>
        </member>
    </members>
</doc>
